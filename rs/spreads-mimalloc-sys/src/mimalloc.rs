/* automatically generated by rust-bindgen 0.57.0 */

extern "C" {
    pub fn mi_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_calloc(count: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_realloc(p: *mut libc::c_void, newsize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_expand(p: *mut libc::c_void, newsize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_free(p: *mut libc::c_void);
}
extern "C" {
    pub fn mi_strdup(s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn mi_strndup(s: *const libc::c_char, n: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn mi_realpath(
        fname: *const libc::c_char,
        resolved_name: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn mi_malloc_small(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_zalloc_small(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_zalloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_mallocn(count: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_reallocn(p: *mut libc::c_void, count: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_reallocf(p: *mut libc::c_void, newsize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_usable_size(p: *const libc::c_void) -> usize;
}
extern "C" {
    pub fn mi_good_size(size: usize) -> usize;
}
pub type mi_deferred_free_fun = ::core::option::Option<
    unsafe extern "C" fn(force: bool, heartbeat: libc::c_ulonglong, arg: *mut libc::c_void),
>;
extern "C" {
    pub fn mi_register_deferred_free(deferred_free: mi_deferred_free_fun, arg: *mut libc::c_void);
}
pub type mi_output_fun =
    ::core::option::Option<unsafe extern "C" fn(msg: *const libc::c_char, arg: *mut libc::c_void)>;
extern "C" {
    pub fn mi_register_output(out: mi_output_fun, arg: *mut libc::c_void);
}
pub type mi_error_fun =
    ::core::option::Option<unsafe extern "C" fn(err: libc::c_int, arg: *mut libc::c_void)>;
extern "C" {
    pub fn mi_register_error(fun: mi_error_fun, arg: *mut libc::c_void);
}
extern "C" {
    pub fn mi_collect(force: bool);
}
extern "C" {
    pub fn mi_version() -> libc::c_int;
}
extern "C" {
    pub fn mi_stats_reset();
}
extern "C" {
    pub fn mi_stats_merge();
}
extern "C" {
    pub fn mi_stats_print(out: *mut libc::c_void);
}
extern "C" {
    pub fn mi_stats_print_out(out: mi_output_fun, arg: *mut libc::c_void);
}
extern "C" {
    pub fn mi_process_init();
}
extern "C" {
    pub fn mi_thread_init();
}
extern "C" {
    pub fn mi_thread_done();
}
extern "C" {
    pub fn mi_thread_stats_print_out(out: mi_output_fun, arg: *mut libc::c_void);
}
extern "C" {
    pub fn mi_process_info(
        elapsed_msecs: *mut usize,
        user_msecs: *mut usize,
        system_msecs: *mut usize,
        current_rss: *mut usize,
        peak_rss: *mut usize,
        current_commit: *mut usize,
        peak_commit: *mut usize,
        page_faults: *mut usize,
    );
}
extern "C" {
    pub fn mi_malloc_aligned(size: usize, alignment: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_malloc_aligned_at(size: usize, alignment: usize, offset: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_zalloc_aligned(size: usize, alignment: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_zalloc_aligned_at(size: usize, alignment: usize, offset: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_calloc_aligned(count: usize, size: usize, alignment: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_calloc_aligned_at(
        count: usize,
        size: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_realloc_aligned(
        p: *mut libc::c_void,
        newsize: usize,
        alignment: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_realloc_aligned_at(
        p: *mut libc::c_void,
        newsize: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mi_heap_s {
    _unused: [u8; 0],
}
pub type mi_heap_t = mi_heap_s;
extern "C" {
    pub fn mi_heap_new() -> *mut mi_heap_t;
}
extern "C" {
    pub fn mi_heap_delete(heap: *mut mi_heap_t);
}
extern "C" {
    pub fn mi_heap_destroy(heap: *mut mi_heap_t);
}
extern "C" {
    pub fn mi_heap_set_default(heap: *mut mi_heap_t) -> *mut mi_heap_t;
}
extern "C" {
    pub fn mi_heap_get_default() -> *mut mi_heap_t;
}
extern "C" {
    pub fn mi_heap_get_backing() -> *mut mi_heap_t;
}
extern "C" {
    pub fn mi_heap_collect(heap: *mut mi_heap_t, force: bool);
}
extern "C" {
    pub fn mi_heap_malloc(heap: *mut mi_heap_t, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_zalloc(heap: *mut mi_heap_t, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_calloc(heap: *mut mi_heap_t, count: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_mallocn(heap: *mut mi_heap_t, count: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_malloc_small(heap: *mut mi_heap_t, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_realloc(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        newsize: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_reallocn(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        count: usize,
        size: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_reallocf(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        newsize: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_strdup(heap: *mut mi_heap_t, s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn mi_heap_strndup(
        heap: *mut mi_heap_t,
        s: *const libc::c_char,
        n: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn mi_heap_realpath(
        heap: *mut mi_heap_t,
        fname: *const libc::c_char,
        resolved_name: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn mi_heap_malloc_aligned(
        heap: *mut mi_heap_t,
        size: usize,
        alignment: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_malloc_aligned_at(
        heap: *mut mi_heap_t,
        size: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_zalloc_aligned(
        heap: *mut mi_heap_t,
        size: usize,
        alignment: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_zalloc_aligned_at(
        heap: *mut mi_heap_t,
        size: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_calloc_aligned(
        heap: *mut mi_heap_t,
        count: usize,
        size: usize,
        alignment: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_calloc_aligned_at(
        heap: *mut mi_heap_t,
        count: usize,
        size: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_realloc_aligned(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        newsize: usize,
        alignment: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_realloc_aligned_at(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        newsize: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_rezalloc(p: *mut libc::c_void, newsize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_recalloc(p: *mut libc::c_void, newcount: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_rezalloc_aligned(
        p: *mut libc::c_void,
        newsize: usize,
        alignment: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_rezalloc_aligned_at(
        p: *mut libc::c_void,
        newsize: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_recalloc_aligned(
        p: *mut libc::c_void,
        newcount: usize,
        size: usize,
        alignment: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_recalloc_aligned_at(
        p: *mut libc::c_void,
        newcount: usize,
        size: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_rezalloc(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        newsize: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_recalloc(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        newcount: usize,
        size: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_rezalloc_aligned(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        newsize: usize,
        alignment: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_rezalloc_aligned_at(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        newsize: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_recalloc_aligned(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        newcount: usize,
        size: usize,
        alignment: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_recalloc_aligned_at(
        heap: *mut mi_heap_t,
        p: *mut libc::c_void,
        newcount: usize,
        size: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_heap_contains_block(heap: *mut mi_heap_t, p: *const libc::c_void) -> bool;
}
extern "C" {
    pub fn mi_heap_check_owned(heap: *mut mi_heap_t, p: *const libc::c_void) -> bool;
}
extern "C" {
    pub fn mi_check_owned(p: *const libc::c_void) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mi_heap_area_s {
    pub blocks: *mut libc::c_void,
    pub reserved: usize,
    pub committed: usize,
    pub used: usize,
    pub block_size: usize,
}
#[test]
fn bindgen_test_layout_mi_heap_area_s() {
    assert_eq!(
        ::core::mem::size_of::<mi_heap_area_s>(),
        40usize,
        concat!("Size of: ", stringify!(mi_heap_area_s))
    );
    assert_eq!(
        ::core::mem::align_of::<mi_heap_area_s>(),
        8usize,
        concat!("Alignment of ", stringify!(mi_heap_area_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mi_heap_area_s>())).blocks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mi_heap_area_s),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mi_heap_area_s>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mi_heap_area_s),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mi_heap_area_s>())).committed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mi_heap_area_s),
            "::",
            stringify!(committed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mi_heap_area_s>())).used as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mi_heap_area_s),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mi_heap_area_s>())).block_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mi_heap_area_s),
            "::",
            stringify!(block_size)
        )
    );
}
pub type mi_heap_area_t = mi_heap_area_s;
pub type mi_block_visit_fun = ::core::option::Option<
    unsafe extern "C" fn(
        heap: *const mi_heap_t,
        area: *const mi_heap_area_t,
        block: *mut libc::c_void,
        block_size: usize,
        arg: *mut libc::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn mi_heap_visit_blocks(
        heap: *const mi_heap_t,
        visit_all_blocks: bool,
        visitor: mi_block_visit_fun,
        arg: *mut libc::c_void,
    ) -> bool;
}
extern "C" {
    pub fn mi_is_in_heap_region(p: *const libc::c_void) -> bool;
}
extern "C" {
    pub fn mi_is_redirected() -> bool;
}
extern "C" {
    pub fn mi_reserve_huge_os_pages_interleave(
        pages: usize,
        numa_nodes: usize,
        timeout_msecs: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mi_reserve_huge_os_pages_at(
        pages: usize,
        numa_node: libc::c_int,
        timeout_msecs: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mi_reserve_os_memory(size: usize, commit: bool, allow_large: bool) -> libc::c_int;
}
extern "C" {
    pub fn mi_manage_os_memory(
        start: *mut libc::c_void,
        size: usize,
        is_committed: bool,
        is_large: bool,
        is_zero: bool,
        numa_node: libc::c_int,
    ) -> bool;
}
extern "C" {
    pub fn mi_debug_show_arenas();
}
extern "C" {
    pub fn mi_reserve_huge_os_pages(
        pages: usize,
        max_secs: f64,
        pages_reserved: *mut usize,
    ) -> libc::c_int;
}
pub const mi_option_e_mi_option_show_errors: mi_option_e = 0;
pub const mi_option_e_mi_option_show_stats: mi_option_e = 1;
pub const mi_option_e_mi_option_verbose: mi_option_e = 2;
pub const mi_option_e_mi_option_eager_commit: mi_option_e = 3;
pub const mi_option_e_mi_option_eager_region_commit: mi_option_e = 4;
pub const mi_option_e_mi_option_reset_decommits: mi_option_e = 5;
pub const mi_option_e_mi_option_large_os_pages: mi_option_e = 6;
pub const mi_option_e_mi_option_reserve_huge_os_pages: mi_option_e = 7;
pub const mi_option_e_mi_option_reserve_os_memory: mi_option_e = 8;
pub const mi_option_e_mi_option_segment_cache: mi_option_e = 9;
pub const mi_option_e_mi_option_page_reset: mi_option_e = 10;
pub const mi_option_e_mi_option_abandoned_page_reset: mi_option_e = 11;
pub const mi_option_e_mi_option_segment_reset: mi_option_e = 12;
pub const mi_option_e_mi_option_eager_commit_delay: mi_option_e = 13;
pub const mi_option_e_mi_option_allow_decommit: mi_option_e = 14;
pub const mi_option_e_mi_option_reset_delay: mi_option_e = 15;
pub const mi_option_e_mi_option_segment_decommit_delay: mi_option_e = 16;
pub const mi_option_e_mi_option_use_numa_nodes: mi_option_e = 17;
pub const mi_option_e_mi_option_limit_os_alloc: mi_option_e = 18;
pub const mi_option_e_mi_option_os_tag: mi_option_e = 19;
pub const mi_option_e_mi_option_max_errors: mi_option_e = 20;
pub const mi_option_e_mi_option_max_warnings: mi_option_e = 21;
pub const mi_option_e__mi_option_last: mi_option_e = 22;
pub type mi_option_e = libc::c_int;
pub use self::mi_option_e as mi_option_t;
extern "C" {
    pub fn mi_option_is_enabled(option: mi_option_t) -> bool;
}
extern "C" {
    pub fn mi_option_enable(option: mi_option_t);
}
extern "C" {
    pub fn mi_option_disable(option: mi_option_t);
}
extern "C" {
    pub fn mi_option_set_enabled(option: mi_option_t, enable: bool);
}
extern "C" {
    pub fn mi_option_set_enabled_default(option: mi_option_t, enable: bool);
}
extern "C" {
    pub fn mi_option_get(option: mi_option_t) -> libc::c_long;
}
extern "C" {
    pub fn mi_option_set(option: mi_option_t, value: libc::c_long);
}
extern "C" {
    pub fn mi_option_set_default(option: mi_option_t, value: libc::c_long);
}
extern "C" {
    pub fn mi_cfree(p: *mut libc::c_void);
}
extern "C" {
    pub fn mi__expand(p: *mut libc::c_void, newsize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_malloc_size(p: *const libc::c_void) -> usize;
}
extern "C" {
    pub fn mi_malloc_usable_size(p: *const libc::c_void) -> usize;
}
extern "C" {
    pub fn mi_posix_memalign(
        p: *mut *mut libc::c_void,
        alignment: usize,
        size: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mi_memalign(alignment: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_valloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_pvalloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_aligned_alloc(alignment: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_reallocarray(p: *mut libc::c_void, count: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_aligned_recalloc(
        p: *mut libc::c_void,
        newcount: usize,
        size: usize,
        alignment: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_aligned_offset_recalloc(
        p: *mut libc::c_void,
        newcount: usize,
        size: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_wcsdup(s: *const libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn mi_mbsdup(s: *const libc::c_uchar) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn mi_dupenv_s(
        buf: *mut *mut libc::c_char,
        size: *mut usize,
        name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mi_wdupenv_s(
        buf: *mut *mut libc::c_ushort,
        size: *mut usize,
        name: *const libc::c_ushort,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mi_free_size(p: *mut libc::c_void, size: usize);
}
extern "C" {
    pub fn mi_free_size_aligned(p: *mut libc::c_void, size: usize, alignment: usize);
}
extern "C" {
    pub fn mi_free_aligned(p: *mut libc::c_void, alignment: usize);
}
extern "C" {
    pub fn mi_new(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_new_aligned(size: usize, alignment: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_new_nothrow(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_new_aligned_nothrow(size: usize, alignment: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_new_n(count: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_new_realloc(p: *mut libc::c_void, newsize: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mi_new_reallocn(p: *mut libc::c_void, newcount: usize, size: usize)
        -> *mut libc::c_void;
}
