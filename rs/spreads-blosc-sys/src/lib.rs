/* automatically generated by rust-bindgen */

extern "C" {
    ///Compress a block of data in the `src` buffer and returns the size of
    ///the compressed block.  The size of `src` buffer is specified by
    ///`nbytes`.  There is not a minimum for `src` buffer size (`nbytes`).
    ///
    ///`clevel` is the desired compression level and must be a number
    ///between 0 (no compression) and 9 (maximum compression).
    ///
    ///`doshuffle` specifies whether the shuffle compression filters
    ///should be applied or not.  BLOSC_NOSHUFFLE means not applying it,
    ///BLOSC_SHUFFLE means applying it at a byte level and BLOSC_BITSHUFFLE
    ///at a bit level (slower but may achieve better entropy alignment).
    ///
    ///`typesize` is the number of bytes for the atomic type in binary
    ///`src` buffer.  This is mainly useful for the shuffle filters.
    ///For implementation reasons, only a 1 < `typesize` < 256 will allow the
    ///shuffle filter to work.  When `typesize` is not in this range, shuffle
    ///will be silently disabled.
    ///
    ///The `dest` buffer must have at least the size of `destsize`.  Blosc
    ///guarantees that if you set `destsize` to, at least,
    ///(`nbytes` + BLOSC_MAX_OVERHEAD), the compression will always succeed.
    ///The `src` buffer and the `dest` buffer can not overlap.
    ///
    ///Compression is memory safe and guaranteed not to write the `dest`
    ///buffer beyond what is specified in `destsize`.
    ///
    ///If `src` buffer cannot be compressed into `destsize`, the return
    ///value is zero and you should discard the contents of the `dest`
    ///buffer.
    ///
    ///A negative return value means that an internal error happened.  This
    ///should never happen.  If you see this, please report it back
    ///together with the buffer data causing this and compression settings.
    ///
    ///Environment variables
    ///---------------------
    ///
    ///blosc_compress() honors different environment variables to control
    ///internal parameters without the need of doing that programatically.
    ///Here are the ones supported:
    ///
    ///BLOSC_CLEVEL=(INTEGER): This will overwrite the `clevel` parameter
    ///before the compression process starts.
    ///
    ///BLOSC_SHUFFLE=[NOSHUFFLE | SHUFFLE | BITSHUFFLE]: This will
    ///overwrite the `doshuffle` parameter before the compression process
    ///starts.
    ///
    ///BLOSC_TYPESIZE=(INTEGER): This will overwrite the `typesize`
    ///parameter before the compression process starts.
    ///
    ///BLOSC_COMPRESSOR=[BLOSCLZ | LZ4 | LZ4HC | SNAPPY | ZLIB]: This will
    ///call blosc_set_compressor(BLOSC_COMPRESSOR) before the compression
    ///process starts.
    ///
    ///BLOSC_NTHREADS=(INTEGER): This will call
    ///blosc_set_nthreads(BLOSC_NTHREADS) before the compression process
    ///starts.
    ///
    ///BLOSC_BLOCKSIZE=(INTEGER): This will call
    ///blosc_set_blocksize(BLOSC_BLOCKSIZE) before the compression process
    ///starts.  *NOTE:* The blocksize is a critical parameter with
    ///important restrictions in the allowed values, so use this with care.
    ///
    ///BLOSC_NOLOCK=(ANY VALUE): This will call blosc_compress_ctx() under
    ///the hood, with the `compressor`, `blocksize` and
    ///`numinternalthreads` parameters set to the same as the last calls to
    ///blosc_set_compressor(), blosc_set_blocksize() and
    ///blosc_set_nthreads().  BLOSC_CLEVEL, BLOSC_SHUFFLE, BLOSC_TYPESIZE
    ///environment vars will also be honored.
    ///
    ///BLOSC_SPLITMODE=[ FORWARD_COMPAT | AUTO | ALWAYS | NEVER ]:
    ///This will call blosc_set_splitmode() with the different supported values.
    ///See blosc_set_splitmode() docstrings for more info on each mode.
    ///
    pub fn blosc_compress(
        clevel: libc::c_int,
        doshuffle: libc::c_int,
        typesize: usize,
        nbytes: usize,
        src: *const libc::c_void,
        dest: *mut libc::c_void,
        destsize: usize,
    ) -> libc::c_int;
}
extern "C" {
    ///Context interface to blosc compression. This does not require a call
    ///to blosc_init() and can be called from multithreaded applications
    ///without the global lock being used, so allowing Blosc be executed
    ///simultaneously in those scenarios.
    ///
    ///It uses the same parameters than the blosc_compress() function plus:
    ///
    ///`compressor`: the string representing the type of compressor to use.
    ///
    ///`blocksize`: the requested size of the compressed blocks.  If 0, an
    ///automatic blocksize will be used.
    ///
    ///`numinternalthreads`: the number of threads to use internally.
    ///
    ///A negative return value means that an internal error happened.  This
    ///should never happen.  If you see this, please report it back
    ///together with the buffer data causing this and compression settings.
    pub fn blosc_compress_ctx(
        clevel: libc::c_int,
        doshuffle: libc::c_int,
        typesize: usize,
        nbytes: usize,
        src: *const libc::c_void,
        dest: *mut libc::c_void,
        destsize: usize,
        compressor: *const libc::c_char,
        blocksize: usize,
        numinternalthreads: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    ///Decompress a block of compressed data in `src`, put the result in
    ///`dest` and returns the size of the decompressed block.
    ///
    ///The `src` buffer and the `dest` buffer can not overlap.
    ///
    ///Decompression is memory safe and guaranteed not to write the `dest`
    ///buffer beyond what is specified in `destsize`.
    ///
    ///If an error occurs, e.g. the compressed data is corrupted or the
    ///output buffer is not large enough, then 0 (zero) or a negative value
    ///will be returned instead.
    ///
    ///Environment variables
    ///---------------------
    ///
    ///blosc_decompress() honors different environment variables to control
    ///internal parameters without the need of doing that programatically.
    ///Here are the ones supported:
    ///
    ///BLOSC_NTHREADS=(INTEGER): This will call
    ///blosc_set_nthreads(BLOSC_NTHREADS) before the proper decompression
    ///process starts.
    ///
    ///BLOSC_NOLOCK=(ANY VALUE): This will call blosc_decompress_ctx()
    ///under the hood, with the `numinternalthreads` parameter set to the
    ///same value as the last call to blosc_set_nthreads().
    pub fn blosc_decompress(
        src: *const libc::c_void,
        dest: *mut libc::c_void,
        destsize: usize,
    ) -> libc::c_int;
}
extern "C" {
    ///Context interface to blosc decompression. This does not require a
    ///call to blosc_init() and can be called from multithreaded
    ///applications without the global lock being used, so allowing Blosc
    ///be executed simultaneously in those scenarios.
    ///
    ///It uses the same parameters than the blosc_decompress() function plus:
    ///
    ///`numinternalthreads`: number of threads to use internally.
    ///
    ///Decompression is memory safe and guaranteed not to write the `dest`
    ///buffer more than what is specified in `destsize`.
    ///
    ///If an error occurs, e.g. the compressed data is corrupted or the
    ///output buffer is not large enough, then 0 (zero) or a negative value
    ///will be returned instead.
    pub fn blosc_decompress_ctx(
        src: *const libc::c_void,
        dest: *mut libc::c_void,
        destsize: usize,
        numinternalthreads: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    ///Returns the current compressor that is being used for compression.
    pub fn blosc_get_compressor() -> *const libc::c_char;
}
extern "C" {
    ///Select the compressor to be used.  The supported ones are "blosclz",
    ///"lz4", "lz4hc", "snappy", "zlib" and "ztsd".  If this function is not
    ///called, then "blosclz" will be used by default.
    ///
    ///In case the compressor is not recognized, or there is not support
    ///for it in this build, it returns a -1.  Else it returns the code for
    ///the compressor (>=0).
    pub fn blosc_set_compressor(compname: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    ///Get a list of compressors supported in the current build.  The
    ///returned value is a string with a concatenation of "blosclz", "lz4",
    ///"lz4hc", "snappy", "zlib" or "zstd "separated by commas, depending
    ///on which ones are present in the build.
    ///
    ///This function does not leak, so you should not free() the returned
    ///list.
    ///
    ///This function should always succeed.
    pub fn blosc_list_compressors() -> *const libc::c_char;
}
extern "C" {
    pub fn compress_lz4(
        input: *const libc::c_char,
        input_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
        clevel: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn decompress_lz4(
        input: *const libc::c_char,
        compressed_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn compress_zstd(
        input: *const libc::c_char,
        input_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
        clevel: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn decompress_zstd(
        input: *const libc::c_char,
        compressed_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn compress_zlib(
        input: *const libc::c_char,
        input_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
        clevel: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn decompress_zlib(
        input: *const libc::c_char,
        compressed_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn compress_deflate(
        input: *const libc::c_char,
        input_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
        clevel: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn decompress_deflate(
        input: *const libc::c_char,
        compressed_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn compress_gzip(
        input: *const libc::c_char,
        input_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
        clevel: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn decompress_gzip(
        input: *const libc::c_char,
        compressed_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn compress_noop(
        input: *const libc::c_char,
        input_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
        clevel: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn decompress_noop(
        input: *const libc::c_char,
        compressed_length: usize,
        output: *mut libc::c_char,
        maxout: usize,
    ) -> libc::c_int;
}
extern "C" {
    ///Primary shuffle and bitshuffle routines.
    ///This function dynamically dispatches to the appropriate hardware-accelerated
    ///routine based on the host processor's architecture. If the host processor is
    ///not supported by any of the hardware-accelerated routines, the generic
    ///(non-accelerated) implementation is used instead.
    ///Consumers should almost always prefer to call this routine instead of directly
    ///calling the hardware-accelerated routines because this method is both cross-
    ///platform and future-proof.
    pub fn shuffle(
        bytesoftype: usize,
        blocksize: usize,
        _src: *const libc::c_char,
        _dest: *const libc::c_char,
    );
}
extern "C" {
    pub fn bitshuffle(
        bytesoftype: usize,
        blocksize: usize,
        _src: *const libc::c_char,
        _dest: *const libc::c_char,
        _tmp: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    ///Primary unshuffle and bitunshuffle routine.
    ///This function dynamically dispatches to the appropriate hardware-accelerated
    ///routine based on the host processor's architecture. If the host processor is
    ///not supported by any of the hardware-accelerated routines, the generic
    ///(non-accelerated) implementation is used instead.
    ///Consumers should almost always prefer to call this routine instead of directly
    ///calling the hardware-accelerated routines because this method is both cross-
    ///platform and future-proof.
    pub fn unshuffle(
        bytesoftype: usize,
        blocksize: usize,
        _src: *const libc::c_char,
        _dest: *const libc::c_char,
    );
}
extern "C" {
    pub fn bitunshuffle(
        bytesoftype: usize,
        blocksize: usize,
        _src: *const libc::c_char,
        _dest: *const libc::c_char,
        _tmp: *const libc::c_char,
    ) -> libc::c_int;
}
